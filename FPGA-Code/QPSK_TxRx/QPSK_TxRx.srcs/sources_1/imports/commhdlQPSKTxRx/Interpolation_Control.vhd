-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\commhdlQPSKTxRx\Interpolation_Control.vhd
-- Created: 2024-01-25 16:33:03
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Interpolation_Control
-- Source Path: commhdlQPSKTxRx/QPSK Rx/Frequency and Time Synchronizer/Symbol Synchronizer/Interpolation Control
-- Hierarchy Level: 3
-- Model version: 7.26
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Interpolation_Control IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        Delta                             :   IN    std_logic_vector(10 DOWNTO 0);  -- sfix11_En10
        mu                                :   OUT   std_logic_vector(10 DOWNTO 0);  -- sfix11_En10
        Underflow                         :   OUT   std_logic
        );
END Interpolation_Control;


ARCHITECTURE rtl OF Interpolation_Control IS

  -- Signals
  SIGNAL Delta_signed                     : signed(10 DOWNTO 0);  -- sfix11_En10
  SIGNAL mu_tmp                           : signed(10 DOWNTO 0);  -- sfix11_En10
  SIGNAL countReg                         : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL underflowReg                     : std_logic;
  SIGNAL muReg                            : signed(10 DOWNTO 0);  -- sfix11
  SIGNAL countReg_next                    : signed(10 DOWNTO 0);  -- sfix11_En10
  SIGNAL underflowReg_next                : std_logic;
  SIGNAL muReg_next                       : signed(10 DOWNTO 0);  -- sfix11_En10

BEGIN
  Delta_signed <= signed(Delta);

  Interpolation_Control_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      countReg <= to_signed(16#000#, 11);
      muReg <= to_signed(16#000#, 11);
      underflowReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        countReg <= countReg_next;
        underflowReg <= underflowReg_next;
        muReg <= muReg_next;
      END IF;
    END IF;
  END PROCESS Interpolation_Control_1_process;

  Interpolation_Control_1_output : PROCESS (Delta_signed, countReg, muReg, underflowReg)
    VARIABLE counter : signed(12 DOWNTO 0);
    VARIABLE y : signed(10 DOWNTO 0);
    VARIABLE x : signed(10 DOWNTO 0);
    VARIABLE droppedBits : signed(10 DOWNTO 0);
    VARIABLE signBitVector : signed(10 DOWNTO 0);
    VARIABLE and_temp : signed(10 DOWNTO 0);
    VARIABLE sub_cast : signed(11 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(11 DOWNTO 0);
    VARIABLE sub_temp : signed(11 DOWNTO 0);
    VARIABLE sub_cast_1 : signed(12 DOWNTO 0);
    VARIABLE add_cast : signed(13 DOWNTO 0);
    VARIABLE add_cast_0 : signed(14 DOWNTO 0);
    VARIABLE add_temp : signed(14 DOWNTO 0);
    VARIABLE cast : signed(13 DOWNTO 0);
  BEGIN
    x := to_signed(16#000#, 11);
    droppedBits := to_signed(16#000#, 11);
    signBitVector := to_signed(16#000#, 11);
    y := to_signed(16#000#, 11);
    add_temp := to_signed(16#0000#, 15);
    add_cast := to_signed(16#0000#, 14);
    add_cast_0 := to_signed(16#0000#, 15);
    cast := to_signed(16#0000#, 14);
    muReg_next <= muReg;
    -- Implementation of modulo-1 counter for interpolation control listed in
    -- Figure 8.4.19 of "Digital Communications - A Discrete-Time Approach"
    -- by Michael Rice. See design details in Chapter 8.4.3 of the same book.
    -- 
    -- Input:
    --   Delta - Loop filter output. If loop is in lock, delta would be small
    -- Output:
    --   Underflow - Indicator of counter underflow. This is the strobe signal
    --               for downstream processing
    --   mu - Difference between actual sampling instant and the optimal instant,
    --        between zero and one
    -- countReg - Counter value delayed by 1 sample
    -- muReg - The estimated timing error normalized by half QPSK symbols
    and_temp := countReg AND to_signed(16#3FF#, 11);
    sub_cast := resize(and_temp, 12);
    sub_cast_0 := resize(Delta_signed, 12);
    sub_temp := sub_cast - sub_cast_0;
    sub_cast_1 := resize(sub_temp, 13);
    counter := sub_cast_1 - to_signed(16#0100#, 13);
    -- decrementing counter
    -- if countReg is a nonnegative number,
    -- then mod(countReg,1) equals the fractional part of countReg
    IF counter < to_signed(16#0000#, 13) THEN 
      underflowReg_next <= '1';
      x := countReg AND to_signed(16#3FF#, 11);
      droppedBits := SHIFT_RIGHT(x, 8);
      signBitVector := SHIFT_RIGHT(x, 10);
      IF droppedBits /= signBitVector THEN 
        y :=  NOT (signBitVector XOR to_signed(-16#400#, 11));
      ELSE 
        y := x sll 2;
      END IF;
      muReg_next <= y;
      add_cast := resize(counter, 14);
      add_cast_0 := resize(add_cast, 15);
      add_temp := add_cast_0 + to_signed(16#0400#, 15);
      IF (add_temp(14) = '0') AND (add_temp(13) /= '0') THEN 
        cast := "01111111111111";
      ELSIF (add_temp(14) = '1') AND (add_temp(13) /= '1') THEN 
        cast := "10000000000000";
      ELSE 
        cast := add_temp(13 DOWNTO 0);
      END IF;
      IF (cast(13) = '0') AND (cast(12 DOWNTO 10) /= "000") THEN 
        countReg_next <= "01111111111";
      ELSIF (cast(13) = '1') AND (cast(12 DOWNTO 10) /= "111") THEN 
        countReg_next <= "10000000000";
      ELSE 
        countReg_next <= cast(10 DOWNTO 0);
      END IF;
      -- create underflow to counter
    ELSE 
      underflowReg_next <= '0';
      IF (counter(12) = '0') AND (counter(11 DOWNTO 10) /= "00") THEN 
        countReg_next <= "01111111111";
      ELSIF (counter(12) = '1') AND (counter(11 DOWNTO 10) /= "11") THEN 
        countReg_next <= "10000000000";
      ELSE 
        countReg_next <= counter(10 DOWNTO 0);
      END IF;
    END IF;
    mu_tmp <= muReg;
    Underflow <= underflowReg;
  END PROCESS Interpolation_Control_1_output;


  mu <= std_logic_vector(mu_tmp);

END rtl;

